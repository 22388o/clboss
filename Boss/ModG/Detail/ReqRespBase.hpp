#ifndef BOSS_MODG_DETAIL_REQRESPBASE_HPP
#define BOSS_MODG_DETAIL_REQRESPBASE_HPP

#include<functional>
#include<map>
#include<memory>
#include<stdexcept>

namespace Ev { template<typename a> class Io; }

namespace Boss { namespace ModG { namespace Detail {

/** class Boss::ModG::Detail::ReqRespBase
 *
 * @brief base non-templated class for `Boss::ModG::ReqResp`,
 * which performs all the logic.
 */
class ReqRespBase {
private:
	typedef
	std::function<void(std::shared_ptr<void>)> PassF;
	typedef
	std::function<void(std::exception_ptr)> FailF;

	struct Entry {
		bool ready;
		PassF pass;
		FailF fail;
	};

	std::map<void*, std::unique_ptr<Entry>> entries;

public:
	/* Fails everything with Boss::Shutdown.  */
	~ReqRespBase();

	/* Causes the request object to be broadcast,
	 * then blocks until a corresponding on_response
	 * call is performed.
	 * Returns a pointer to some response message
	 * provided by a corresponding on_response.
	 */
	Ev::Io<std::shared_ptr<void>>
	execute( std::shared_ptr<void> request
	       /* Function that annotates the request message
		* with a pointer that will also be copied to
		* the corresponding response message.
		*/
	       , std::function<void( std::shared_ptr<void> const&
				   , void*
				   )> const& set_annotation
	       /* Function to actually broadcast the request.   */
	       , std::function<Ev::Io<void>(std::shared_ptr<void>)
			      > const& broadcast
	       );

	/* Called whenever a response message is broadcasted.
	 * If the response is annotated with a pointer that is
	 * recognized as one generated by the `execute` function,
	 * then the corresponding execution will resume.
	 */
	Ev::Io<void>
	on_response( std::shared_ptr<void> response
		   /* Function to extract the annotation from the
		    * response.  */
		   , std::function<void*(std::shared_ptr<void> const&)
				  > const& get_annotation
		   );

private:
	static
	Ev::Io<void> wait_entry_ready(Entry& entry);
};

}}}

#endif /* BOSS_MODG_DETAIL_REQRESPBASE_HPP */
